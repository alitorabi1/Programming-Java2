Learn how to create the following GUI components:
• Windows
• Labels
• Text fields
• Buttons


GUI components, such as labels, are placed in an area called the content pane of the window. You can think of a content pane as the inner area of the window, below the title bar and inside the border. You will also learn how to place these GUI components in the content pane of a window.


For example, when you click the Calculate button, the program displays the area and perimeter of the rectangle you have specified. This means that clicking the Calculate button causes the program to execute the code to calculate the area and perimeter and then display the results. 

When the Calculate button is clicked, we say that an event has occurred. The Java system is very prompt in listening for the events generated by a program and then reacting to those events. 

We will describe how to write the code that needs to be executed when a particular event occurs, such as when a button is clicked. So, in addition to creating windows, labels, text fields, and buttons, you will learn:
• How to access the content pane
• How to create event listeners
• How to process or handle events


Creating a Window
==================
GUI components such as windows and labels are, in fact, objects. Recall that an object is an instance of a particular class. Therefore, these components (objects) are instances of a particular class type. 
JFrame is a class and the GUI component window can be created by using a JFrame object. Various attributes are associated with a window. For example:
• Every window has a title.
• Every window has width and height.


JFrame
=======
The class JFrame provides various methods to control the attributes of a window. For example, it has methods to set the window title and methods to specify the height and width of the window. Table 6-1 describes some of the methods provided by the class JFrame.

There are two ways to make an application program create a window. 
1. The first way is to declare an object of type JFrame, instantiate the object, and then use various methods to manipulate the window. In this case, the object created can use the various applicable methods of the class.

2. The second way is to create the class containing the application program by extending the definition of the class JFrame; that is, the class containing the application program is built "on top of" the class JFrame. In Java, this way of creating a class uses the mechanism of inheritance. 
Inheritance means that a new class can be derived from or based on an already existing class. The new class "inherits" features such as methods from the existing class, which saves a lot of time for programmers. For example, we could define a new class RectangleProgram that would extend the definition of JFrame.

The class RectangleProgram would be able to use the variables and methods from JFrame, and also add some functionality of its own (such as the ability to calculate the area and perimeter of a rectangle).

When you use inheritance, the class containing your application program will have more than one method. In addition to the method main, you will have at least one other method that will be used to create a window object containing the required GUI components (such as labels and text fields). 

This additional method is a special type of method called a constructor. A constructor is a method of a class that is automatically executed when an object of the class is created. Typically, a constructor is used to initialize an object. The name of the constructor is always the same as the name of the class. For example, the constructor for the class RectangleProgram would be named RectangleProgram.


Because inheritance is an important concept in programming languages such as Java, we will use the second way of creating a window. We will extend the definition of the class JFrame by using the modifier extends. For example, the definition of the class RectangleProgram, containing the application program to calculate the area and perimeter of a rectangle, is as follows:

public class RectangleProgram extends JFrame
{
   public RectangleProgram() //constructor
   {
	//Necessary code
   }

   public static void main(String[] args)
   {
   	//Code for the method main
   }
}

In Java, extends is a reserved word. The remainder of this section describes the necessary code to create a window.

An important property of inheritance is that the class (called a subclass) that extends the definition of an existing class (called a superclass) inherits all the properties of the superclass. For example, all public methods of the superclass can be directly accessed in the subclass. 

In our example, the class RectangleProgram is a subclass of the class JFrame, so it can access the public methods of the class JFrame. Therefore, to set the title of the window to Area and Perimeter of a Rectangle, you use the method setTitle of the class JFrame as follows:
	setTitle("Area and Perimeter of a Rectangle"); //Line 1
Similarly, the statement:
	setSize(400, 300); //Line 2 sets the window’s width to 400 pixels and its height to 300 pixels. 

Next, to display the window, you must invoke the method setVisible. The following statement accomplishes this:
	setVisible(true); //Line 3

To terminate the application program when the user closes the window, use the following statement:
	setDefaultCloseOperation(EXIT_ON_CLOSE); //Line 4

The statements in Lines 1, 2, 3, and 4 will be placed in the constructor (that is, in the method whose heading is public RectangleProgram() ).

public RectangleProgram()
{
   setTitle("Area and Perimeter of a Rectangle");
   setSize(400, 300);
   setDefaultCloseOperation(EXIT_ON_CLOSE);
   setVisible(true);
}


You could create a window by using an object of type JFrame. However, for our program, if we do so, then the window created will not have a title or the required size unless we specify the necessary statements similar to the ones in the preceding code. 

Because RectangleProgram is also a class, we can create objects of type RectangleProgram. Because the class RectangleProgram extends the definition of the class JFrame, it inherits the properties of the class JFrame. If we create an object of type RectangleProgram, not only do we create a window, but the created window will also have a title and a specific size, and the window will be displayed when the program executes.

Consider the following statement:
	RectangleProgram rectObject = new RectangleProgram(); //Line 5

This statement creates the object rectObject of type RectangleProgram.


Remember that the named constants WIDTH and HEIGHT are declared with the modifier private. This is because we want these named constants to be used only within the class RectangleProgram. In general, if a named constant, variable, or method is to be used only within the specified class, then it is declared with the modifier private. Also, note that private is a reserved word in Java. 


Let's review the important points introduced in this section:
• The preceding program has exactly one class: RectangleProgramOne.
• The class RectangleProgramOne contains the constructor RectangleProgramOne and the main method.
• You created the new class RectangleProgramOne by extending the existing class, JFrame. Therefore, JFrame is the superclass of RectangleProgramOne, and RectangleProgramOne is a subclass of JFrame.
• Whenever there is a superclass–subclass relationship, the subclass inherits all the data members and methods of the superclass. The methods setTitle, setSize, setVisible, and setDefaultCloseOperation are methods of the class JFrame, and these methods can be inherited by its subclasses.


Getting Access to the Content Pane
==================================
If you can visualize JFrame as a window, think of the content pane as the inner area of the window (below the title bar and inside the border). The class JFrame has the method getContentPane that you can use to access the content pane of the window. However, the class JFrame does not have the necessary tools to manage the components of the content pane. The components of the content pane are managed by declaring a reference variable of the Container type and then using the method getContentPane.

Consider the following statements:

	Container pane; //Line 1
	pane = getContentPane(); //Line 2

The statement in Line 1 declares pane to be a reference variable of the Container type. The statement in Line 2 gets the content pane of the window as a container, that is, the reference variable pane now points to the content pane. You can now access the content pane to add GUI components to it by using the reference variable pane.


The statements in Lines 1 and 2 can be combined into one statement:
	Container pane = getContentPane(); //Line 3

To control the placement of GUI components in the content pane, you set the layout of the content pane, for example, grid layout. The class Container provides the method setLayout, to set the layout of the content pane. To add components such as labels and text fields to the content pane, you use the method add of the class Container.

The class Container is contained in the package java.awt. To use this class in your program, you need to include one of the following statements:
	import java.awt.*;
or:
	import java.awt.Container;


As noted earlier, the method setLayout is used to set the layout of the content pane, pane. To set the layout of the container to a grid, you use the class GridLayout.

Consider the following statement:
	pane.setLayout(new GridLayout(5, 2));

This statement creates an object belonging to the class GridLayout and assigns that object as the layout of the content pane, pane, by invoking the setLayout method. Moreover, this statement sets the layout of the content pane, pane, to five rows and two columns. This allows you to add 10 components arranged in five rows and two columns.

Note that the GridLayout manager arranges GUI components in a matrix formation with the number of rows and columns defined by the constructor and that the components are placed left to right, starting with the first row. For example, in the statement pane.setLayout(new GridLayout(5, 2));, the expression new GridLayout(5, 2), invokes the constructor of the class GridLayout and sets the number of rows to 5 and the number of columns to 2.

If you do not specify a layout, Java uses a default layout. If you specify a layout, you must set the layout before adding any components. Once the layout is set, you can use the method add to add the components to the pane.


JLabel class
============
Labels are objects of a particular class type. The Java class that you use to create labels is JLabel. Therefore, to create labels, you instantiate objects of type JLabel. The class JLabel is contained in the package javax.swing.

Just like a window, various attributes are associated with a label. For example, every label has a title, width, and height. The class JLabel contains various methods to control the display of labels. 

Consider the statements:
private JLabel lengthL, widthL, areaL, perimeterL;
lengthL = new JLabel("Enter the length:", SwingConstants.RIGHT);
...
perimeterL = new JLabel("Perimeter: ", SwingConstants.RIGHT);


We assume the following statements:

	Container pane = getContentPane();
	pane.setLayout(new GridLayout(4, 1));

Next, we add these labels to the pane (Container instance). The following statements accomplish this. We use the method add to add components to a pane.)

pane.add(lengthL);
pane.add(widthL);
pane.add(areaL);
pane.add(perimeterL);

Because we have specified a grid layout for the pane with four rows and one column, the label lengthL is added to the first row, the label widthL is added to the second row, and so on.

JTextField
===========
As you may recall, text fields are objects belonging to the class JTextField. Therefore, you can create a text field by declaring a reference variable of type JTextField followed by an instantiation of the object.

Consider the following statements:
private JTextField lengthTF, widthTF, areaTF,
perimeterTF; //Line 1
lengthTF = new JTextField(10); //Line 2
...
...

The statement in Line 1 declares four reference variables, lengthTF, widthTF, areaTF, and perimeterTF, of type JTextField. The statement in Line 2 instantiates the object lengthTF and sets the width of this text field to 10 characters. That is, this text field can display no more than 10 characters. The meaning of the other statements is similar.

Placing these objects involves using the add method of the class Container as described in the previous section. The following statements add these components to the container:

pane.add(lengthTF);
...
...
pane.add(perimeterTF);


The container pane now would contain eight objects—four labels and four text fields. We want to place the object lengthTF adjacent to the label lengthL in the same row, and use similar placements for the other objects. So we need to expand the grid layout to four rows and two columns. The following statements create the required grid layout and the necessary objects:

pane.setLayout(new GridLayout(4, 2));
pane.add(lengthL);
pane.add(lengthTF);
...
...


JButton class
===============
To create a button, Java provides the class JButton. Thus, to create objects belonging to the class JButton, we use a technique similar to the one we used to create instances of JLabel and JTextField. T

JButton calculateB, exitB; //Line 1
calculateB = new JButton("Calculate"); //Line 2
exitB = new JButton("Exit"); //Line 3

The statement in Line 1 declares calculateB and exitB to be reference variables of type JButton. The statement in Line 2 instantiates the button object calculateB and sets the text for the button to the string Calculate. Similarly, the statement in Line 3 instantiates the button object exitB and sets the text for exitB to the string Exit.

The buttons calculateB and exitB can be placed into the container pane by using the method add. The following statements add these buttons to the pane:
pane.add(calculateB);
pane.add(exitB);


Now you have two more objects in the container, so you need to modify the GridLayout to accommodate five rows and two columns, and then add all the components. The following statements create the required grid layout and add the labels, text fields, and buttons to the container pane:
pane.setLayout(new GridLayout(5,2));//specify the layout


pane.add(lengthL); //add the label lengthL
pane.add(lengthTF); //add the text field lengthTF
...
...
pane.add(calculateB); //add the button calculateB
pane.add(exitB); //add the button exitB

Notice that the preceding add statements place the components from left to right and from top to bottom.


HANDLING AN EVENT
=================
You have now learned how to create a window, how to create a container, and how to create labels, text fields, and buttons.

Now that you can create a button, such as calculateB, you need to specify how such a button should behave when you click it. 

For example, when you click the button calculateB, you want the program to calculate the area and perimeter of the rectangle 

and display these values in their respective text fields. Similarly, when you click the button exitB, the program should terminate.

Clicking a JButton creates an event, known as an action event, which sends a message to another object, 

known as an action listener. When the listener receives the message, it performs some action. 

Sending a message or an event to a listener object simply means that some method in the listener object is invoked 

with the event as the argument. This invocation happens automatically; you will not see the code corresponding 

to the method invocation. However, you must specify two things:

• For each JButton, you must specify the corresponding listener object. In Java, this is known as registering the listener.

• You must define the methods that will be invoked when the event is sent to the listener. 

Normally, you will write these methods and you will never write the code for invocation.


Java provides various classes to handle different kinds of events. The action event is handled by the class ActionListener, 

which contains only the method actionPerformed. In the method actionPerformed, you include the code that you want 

the system to execute when an action event is generated.


The class ActionListener that handles the action event is a special type of class, called an interface. 

In Java, interface is a reserved word. Roughly speaking, an interface is a class that contains only the method headings, 

and each method heading is terminated with a semicolon. For example, the definition of the interface ActionListener 

containing the method actionPerformed is:

public interface ActionListener
{
   public void actionPerformed(ActionEvent e);
}


Because the method actionPerformed does not contain a body, Java does not allow you to instantiate an object of type 

ActionListener. So how do you register an action listener with the object calculateB?

One way is as follows: Because you cannot instantiate an object of type ActionListener, first you need to create a class 

on top of ActionListener so that the required object can be instantiated. The class created must provide the necessary code 

for the method actionPerformed. You will create the class CalculateButtonHandler to handle the event generated by clicking 

the button calculateB.


The class CalculateButtonHandler is created on top of the interface ActionListener. The definition of the class 

CalculateButtonHandler is:

private class CalculateButtonHandler implements ActionListener //Line 1
{
   public void actionPerformed(ActionEvent e) //Line 2
   {
	//The code for calculating the area and the perimeter
	//and displaying these quantities goes here
   }
}


Notice the following:
• The class CalculateButtonHandler starts with the modifier private. This is because you want this class to be used only 
within your RectangleProgram.

• This class uses another modifier, implements. This is how you build classes on top of classes that are interfaces. 

In Java, implements is a reserved word.


To create a listener object of type CalculateButtonHandler, consider the following statements:

	CalculateButtonHandler cbHandler;

	cbHandler = new CalculateButtonHandler(); //instantiate the object

These statements create the listener object. Having created a listener, you next must associate (or in Java terminology, register) 

this handler with the corresponding JButton. The following line of code registers cbHandler as the listener object of calculateB:

	calculateB.addActionListener(cbHandler);


Before creating an action listener for the JButton exitB, let us summarize what we’ve done so far to create and register 
an action event listener:

1. Created a class that implements the interface ActionListener. For example, for the JButton calculateB we created 
the class CalculateButtonHandler.

2. Provided the definition of the method actionPerformed within the class that you created in Step 1. The method actionPerformed 
contains the code that the program executes when a specific event is generated. For example, when you click the JButton 
calculateB, the program should calculate and display the area and perimeter of the rectangle.

3. Created and instantiated an object of the class type created in Step 1. For example, for the JButton calculateB we created 
the object cbHandler.

4. Registered the event handler created in Step 3 with the object that generates an action event using the method 
addActionListener. For example, for JButton calculateB the following statement registers the object cbHandler to listen and 
register the action event:
	calculateB.addActionListener(cbHandler);

The interface ActionListener is contained in the package java.awt.event. Therefore, to use this interface to handle events, 
your program must include the statement:

	import java.awt.event.*;
or:
	import java.awt.event.ActionListener;

